export default {
    fileName: `/lib.webworker.d.ts`,
    // File text is copyright Microsoft Corporation and is distributed under the Apache License, Version 2.0 (http://www.apache.org/licenses/LICENSE-2.0)
    text: `/// <reference no-default-lib="true"/>\ninterface AddEventListenerOptionsextends EventListenerOptions{once?:boolean ;passive?:boolean ;}interface Algorithm{name:string ;}interface BlobPropertyBag{type ?:string ;}interface CacheQueryOptions{cacheName?:string ;ignoreMethod?:boolean ;ignoreSearch?:boolean ;ignoreVary?:boolean ;}interface ClientQueryOptions{includeUncontrolled?:boolean ;type ?:ClientTypes;}interface CloseEventInitextends EventInit{code?:number ;reason?:string ;wasClean?:boolean ;}interface DOMMatrix2DInit{a?:number ;b?:number ;c?:number ;d?:number ;e?:number ;f?:number ;m11?:number ;m12?:number ;m21?:number ;m22?:number ;m41?:number ;m42?:number ;}interface DOMMatrixInitextends DOMMatrix2DInit{is2D?:boolean ;m13?:number ;m14?:number ;m23?:number ;m24?:number ;m31?:number ;m32?:number ;m33?:number ;m34?:number ;m43?:number ;m44?:number ;}interface DOMPointInit{w?:number ;x?:number ;y?:number ;z?:number ;}interface DOMQuadInit{p1?:DOMPointInit;p2?:DOMPointInit;p3?:DOMPointInit;p4?:DOMPointInit;}interface DOMRectInit{height?:number ;width?:number ;x?:number ;y?:number ;}interface ErrorEventInitextends EventInit{colno?:number ;error?:any ;filename?:string ;lineno?:number ;message?:string ;}interface EventInit{bubbles?:boolean ;cancelable?:boolean ;composed?:boolean ;}interface EventListenerOptions{capture?:boolean ;}interface ExtendableEventInitextends EventInit{}interface ExtendableMessageEventInitextends ExtendableEventInit{data?:any ;lastEventId?:string ;origin?:string ;ports?:MessagePort[];source?:Client|ServiceWorker|MessagePort;}interface FetchEventInitextends ExtendableEventInit{clientId?:string ;preloadResponse:Promise<any >;request:Request;resultingClientId?:string ;targetClientId?:string ;}interface FilePropertyBagextends BlobPropertyBag{lastModified?:number ;}interface GetNotificationOptions{tag?:string ;}interface IDBIndexParameters{multiEntry?:boolean ;unique ?:boolean ;}interface IDBObjectStoreParameters{autoIncrement?:boolean ;keyPath?:string |string [];}interface IDBVersionChangeEventInitextends EventInit{newVersion?:number |null ;oldVersion?:number ;}interface KeyAlgorithm{name:string ;}interface MessageEventInitextends EventInit{channel?:string ;data?:any ;lastEventId?:string ;origin?:string ;ports?:MessagePort[];source?:object |null ;}interface NavigationPreloadState{enabled?:boolean ;headerValue?:string ;}interface NotificationAction{action:string ;icon?:string ;title:string ;}interface NotificationEventInitextends ExtendableEventInit{action?:string ;notification:Notification;}interface NotificationOptions{actions?:NotificationAction[];badge?:string ;body?:string ;data?:any ;dir?:NotificationDirection;icon?:string ;image?:string ;lang?:string ;renotify?:boolean ;requireInteraction?:boolean ;silent?:boolean ;tag?:string ;timestamp?:number ;vibrate?:VibratePattern;}interface PerformanceObserverInit{buffered?:boolean ;entryTypes:string [];}interface ProgressEventInitextends EventInit{lengthComputable?:boolean ;loaded?:number ;total?:number ;}interface PromiseRejectionEventInitextends EventInit{promise:Promise<any >;reason?:any ;}interface PushEventInitextends ExtendableEventInit{data?:PushMessageDataInit;}interface PushSubscriptionChangeInitextends ExtendableEventInit{newSubscription?:PushSubscription;oldSubscription?:PushSubscription;}interface PushSubscriptionJSON{endpoint?:string ;expirationTime?:number |null ;keys?:Record<string ,string >;}interface PushSubscriptionOptionsInit{applicationServerKey?:BufferSource|string ;userVisibleOnly?:boolean ;}interface RegistrationOptions{scope?:string ;type ?:WorkerType;updateViaCache?:ServiceWorkerUpdateViaCache;}interface RequestInit{body?:BodyInit|null ;cache?:RequestCache;credentials?:RequestCredentials;headers?:HeadersInit;integrity?:string ;keepalive?:boolean ;method?:string ;mode?:RequestMode;redirect?:RequestRedirect;referrer?:string ;referrerPolicy?:ReferrerPolicy;signal?:object |null ;window?:any ;}interface ResponseInit{headers?:HeadersInit;status?:number ;statusText?:string ;}interface StorageEstimate{quota?:number ;usage?:number ;}interface SyncEventInitextends ExtendableEventInit{lastChance?:boolean ;tag:string ;}interface TextDecodeOptions{stream?:boolean ;}interface TextDecoderOptions{fatal?:boolean ;ignoreBOM?:boolean ;}interface EventListener{(evt:Event):void ;}interface AbstractWorkerEventMap{"error":ErrorEvent;}interface AbstractWorker{onerror:((this :AbstractWorker,ev:ErrorEvent)=>any )|null ;addEventListener<Kextends keyof AbstractWorkerEventMap>(type :K,listener:(this :AbstractWorker,ev:AbstractWorkerEventMap[K])=>any ,options?:boolean |AddEventListenerOptions):void ;addEventListener(type :string ,listener:EventListenerOrEventListenerObject,options?:boolean |AddEventListenerOptions):void ;removeEventListener<Kextends keyof AbstractWorkerEventMap>(type :K,listener:(this :AbstractWorker,ev:AbstractWorkerEventMap[K])=>any ,options?:boolean |EventListenerOptions):void ;removeEventListener(type :string ,listener:EventListenerOrEventListenerObject,options?:boolean |EventListenerOptions):void ;}interface AesCfbParamsextends Algorithm{iv:Int8Array|Int16Array|Int32Array|Uint8Array|Uint16Array|Uint32Array|Uint8ClampedArray|Float32Array|Float64Array|DataView|ArrayBuffer;}interface AesCmacParamsextends Algorithm{length:number ;}interface Blob{readonly size:number ;readonly type :string ;slice(start?:number ,end?:number ,contentType?:string ):Blob;}declare var Blob:{prototype:Blob;new (blobParts?:BlobPart[],options?:BlobPropertyBag):Blob;};interface Body{readonly body:ReadableStream|null ;readonly bodyUsed:boolean ;arrayBuffer():Promise<ArrayBuffer>;blob():Promise<Blob>;formData():Promise<FormData>;json():Promise<any >;text():Promise<string >;}interface BroadcastChannelEventMap{"message":MessageEvent;"messageerror":MessageEvent;}interface BroadcastChannelextends EventTarget{/**\n * Returns the channel name (as passed to the constructor).\n */readonly name:string ;onmessage:((this :BroadcastChannel,ev:MessageEvent)=>any )|null ;onmessageerror:((this :BroadcastChannel,ev:MessageEvent)=>any )|null ;/**\n * Closes the BroadcastChannel object, opening it up to garbage collection.\n */close():void ;/**\n * Sends the given message to other BroadcastChannel objects set up for this channel. Messages can be structured objects, e.g. nested objects and arrays.\n */postMessage(message:any ):void ;addEventListener<Kextends keyof BroadcastChannelEventMap>(type :K,listener:(this :BroadcastChannel,ev:BroadcastChannelEventMap[K])=>any ,options?:boolean |AddEventListenerOptions):void ;addEventListener(type :string ,listener:EventListenerOrEventListenerObject,options?:boolean |AddEventListenerOptions):void ;removeEventListener<Kextends keyof BroadcastChannelEventMap>(type :K,listener:(this :BroadcastChannel,ev:BroadcastChannelEventMap[K])=>any ,options?:boolean |EventListenerOptions):void ;removeEventListener(type :string ,listener:EventListenerOrEventListenerObject,options?:boolean |EventListenerOptions):void ;}declare var BroadcastChannel:{prototype:BroadcastChannel;new (name:string ):BroadcastChannel;};interface BroadcastChannelEventMap{message:MessageEvent;messageerror:MessageEvent;}interface Cache{add(request:RequestInfo):Promise<void >;addAll(requests:RequestInfo[]):Promise<void >;delete (request:RequestInfo,options?:CacheQueryOptions):Promise<boolean >;keys(request?:RequestInfo,options?:CacheQueryOptions):Promise<ReadonlyArray<Request>>;match(request:RequestInfo,options?:CacheQueryOptions):Promise<Response|undefined >;matchAll(request?:RequestInfo,options?:CacheQueryOptions):Promise<ReadonlyArray<Response>>;put(request:RequestInfo,response:Response):Promise<void >;}declare var Cache:{prototype:Cache;new ():Cache;};interface CacheStorage{delete (cacheName:string ):Promise<boolean >;has(cacheName:string ):Promise<boolean >;keys():Promise<string []>;match(request:RequestInfo,options?:CacheQueryOptions):Promise<Response|undefined >;open(cacheName:string ):Promise<Cache>;}declare var CacheStorage:{prototype:CacheStorage;new ():CacheStorage;};interface Client{readonly id:string ;readonly type :ClientTypes;readonly url:string ;postMessage(message:any ,transfer?:any []):void ;}declare var Client:{prototype:Client;new ():Client;};interface Clients{claim():Promise<void >;get (id:string ):Promise<any >;matchAll(options?:ClientQueryOptions):Promise<ReadonlyArray<Client>>;openWindow(url:string ):Promise<WindowClient|null >;}declare var Clients:{prototype:Clients;new ():Clients;};interface CloseEventextends Event{readonly code:number ;readonly reason:string ;readonly wasClean:boolean ;/** @deprecated */initCloseEvent(typeArg:string ,canBubbleArg:boolean ,cancelableArg:boolean ,wasCleanArg:boolean ,codeArg:number ,reasonArg:string ):void ;}declare var CloseEvent:{prototype:CloseEvent;new (type :string ,eventInitDict?:CloseEventInit):CloseEvent;};interface ConcatParamsextends Algorithm{algorithmId:Uint8Array;hash?:string |Algorithm;partyUInfo:Uint8Array;partyVInfo:Uint8Array;privateInfo?:Uint8Array;publicInfo?:Uint8Array;}interface Console{memory:any ;assert(condition?:boolean ,message?:string ,...data:any []):void ;clear():void ;count(label?:string ):void ;debug(message?:any ,...optionalParams:any []):void ;dir(value?:any ,...optionalParams:any []):void ;dirxml(value:any ):void ;error(message?:any ,...optionalParams:any []):void ;exception(message?:string ,...optionalParams:any []):void ;group(groupTitle?:string ,...optionalParams:any []):void ;groupCollapsed(groupTitle?:string ,...optionalParams:any []):void ;groupEnd():void ;info(message?:any ,...optionalParams:any []):void ;log(message?:any ,...optionalParams:any []):void ;markTimeline(label?:string ):void ;msIsIndependentlyComposed(element:object ):boolean ;profile(reportName?:string ):void ;profileEnd():void ;select(element:object ):void ;table(...tabularData:any []):void ;time(label?:string ):void ;timeEnd(label?:string ):void ;timeStamp(label?:string ):void ;timeline(label?:string ):void ;timelineEnd(label?:string ):void ;trace(message?:any ,...optionalParams:any []):void ;warn(message?:any ,...optionalParams:any []):void ;}declare var Console:{prototype:Console;new ():Console;};interface CryptoKey{readonly algorithm:KeyAlgorithm;readonly extractable:boolean ;readonly type :string ;readonly usages:string [];}declare var CryptoKey:{prototype:CryptoKey;new ():CryptoKey;};interface DOMException{readonly code:number ;readonly message:string ;readonly name:string ;readonly ABORT_ERR:number ;readonly DATA_CLONE_ERR:number ;readonly DOMSTRING_SIZE_ERR:number ;readonly HIERARCHY_REQUEST_ERR:number ;readonly INDEX_SIZE_ERR:number ;readonly INUSE_ATTRIBUTE_ERR:number ;readonly INVALID_ACCESS_ERR:number ;readonly INVALID_CHARACTER_ERR:number ;readonly INVALID_MODIFICATION_ERR:number ;readonly INVALID_NODE_TYPE_ERR:number ;readonly INVALID_STATE_ERR:number ;readonly NAMESPACE_ERR:number ;readonly NETWORK_ERR:number ;readonly NOT_FOUND_ERR:number ;readonly NOT_SUPPORTED_ERR:number ;readonly NO_DATA_ALLOWED_ERR:number ;readonly NO_MODIFICATION_ALLOWED_ERR:number ;readonly QUOTA_EXCEEDED_ERR:number ;readonly SECURITY_ERR:number ;readonly SYNTAX_ERR:number ;readonly TIMEOUT_ERR:number ;readonly TYPE_MISMATCH_ERR:number ;readonly URL_MISMATCH_ERR:number ;readonly VALIDATION_ERR:number ;readonly WRONG_DOCUMENT_ERR:number ;}declare var DOMException:{prototype:DOMException;new (message?:string ,name?:string ):DOMException;readonly ABORT_ERR:number ;readonly DATA_CLONE_ERR:number ;readonly DOMSTRING_SIZE_ERR:number ;readonly HIERARCHY_REQUEST_ERR:number ;readonly INDEX_SIZE_ERR:number ;readonly INUSE_ATTRIBUTE_ERR:number ;readonly INVALID_ACCESS_ERR:number ;readonly INVALID_CHARACTER_ERR:number ;readonly INVALID_MODIFICATION_ERR:number ;readonly INVALID_NODE_TYPE_ERR:number ;readonly INVALID_STATE_ERR:number ;readonly NAMESPACE_ERR:number ;readonly NETWORK_ERR:number ;readonly NOT_FOUND_ERR:number ;readonly NOT_SUPPORTED_ERR:number ;readonly NO_DATA_ALLOWED_ERR:number ;readonly NO_MODIFICATION_ALLOWED_ERR:number ;readonly QUOTA_EXCEEDED_ERR:number ;readonly SECURITY_ERR:number ;readonly SYNTAX_ERR:number ;readonly TIMEOUT_ERR:number ;readonly TYPE_MISMATCH_ERR:number ;readonly URL_MISMATCH_ERR:number ;readonly VALIDATION_ERR:number ;readonly WRONG_DOCUMENT_ERR:number ;};interface DOMMatrixextends DOMMatrixReadOnly{a:number ;b:number ;c:number ;d:number ;e:number ;f:number ;m11:number ;m12:number ;m13:number ;m14:number ;m21:number ;m22:number ;m23:number ;m24:number ;m31:number ;m32:number ;m33:number ;m34:number ;m41:number ;m42:number ;m43:number ;m44:number ;invertSelf():DOMMatrix;multiplySelf(other?:DOMMatrixInit):DOMMatrix;preMultiplySelf(other?:DOMMatrixInit):DOMMatrix;rotateAxisAngleSelf(x?:number ,y?:number ,z?:number ,angle?:number ):DOMMatrix;rotateFromVectorSelf(x?:number ,y?:number ):DOMMatrix;rotateSelf(rotX?:number ,rotY?:number ,rotZ?:number ):DOMMatrix;scale3dSelf(scale?:number ,originX?:number ,originY?:number ,originZ?:number ):DOMMatrix;scaleSelf(scaleX?:number ,scaleY?:number ,scaleZ?:number ,originX?:number ,originY?:number ,originZ?:number ):DOMMatrix;skewXSelf(sx?:number ):DOMMatrix;skewYSelf(sy?:number ):DOMMatrix;translateSelf(tx?:number ,ty?:number ,tz?:number ):DOMMatrix;}declare var DOMMatrix:{prototype:DOMMatrix;new (init?:string |number []):DOMMatrix;fromFloat32Array(array32:Float32Array):DOMMatrix;fromFloat64Array(array64:Float64Array):DOMMatrix;fromMatrix(other?:DOMMatrixInit):DOMMatrix;};interface DOMMatrixReadOnly{readonly a:number ;readonly b:number ;readonly c:number ;readonly d:number ;readonly e:number ;readonly f:number ;readonly is2D:boolean ;readonly isIdentity:boolean ;readonly m11:number ;readonly m12:number ;readonly m13:number ;readonly m14:number ;readonly m21:number ;readonly m22:number ;readonly m23:number ;readonly m24:number ;readonly m31:number ;readonly m32:number ;readonly m33:number ;readonly m34:number ;readonly m41:number ;readonly m42:number ;readonly m43:number ;readonly m44:number ;flipX():DOMMatrix;flipY():DOMMatrix;inverse():DOMMatrix;multiply(other?:DOMMatrixInit):DOMMatrix;rotate(rotX?:number ,rotY?:number ,rotZ?:number ):DOMMatrix;rotateAxisAngle(x?:number ,y?:number ,z?:number ,angle?:number ):DOMMatrix;rotateFromVector(x?:number ,y?:number ):DOMMatrix;scale(scaleX?:number ,scaleY?:number ,scaleZ?:number ,originX?:number ,originY?:number ,originZ?:number ):DOMMatrix;scale3d(scale?:number ,originX?:number ,originY?:number ,originZ?:number ):DOMMatrix;skewX(sx?:number ):DOMMatrix;skewY(sy?:number ):DOMMatrix;toFloat32Array():Float32Array;toFloat64Array():Float64Array;toJSON():any ;transformPoint(point?:DOMPointInit):DOMPoint;translate(tx?:number ,ty?:number ,tz?:number ):DOMMatrix;}declare var DOMMatrixReadOnly:{prototype:DOMMatrixReadOnly;new (init?:string |number []):DOMMatrixReadOnly;fromFloat32Array(array32:Float32Array):DOMMatrixReadOnly;fromFloat64Array(array64:Float64Array):DOMMatrixReadOnly;fromMatrix(other?:DOMMatrixInit):DOMMatrixReadOnly;};interface DOMPointextends DOMPointReadOnly{w:number ;x:number ;y:number ;z:number ;}declare var DOMPoint:{prototype:DOMPoint;new (x?:number ,y?:number ,z?:number ,w?:number ):DOMPoint;fromPoint(other?:DOMPointInit):DOMPoint;};interface DOMPointReadOnly{readonly w:number ;readonly x:number ;readonly y:number ;readonly z:number ;matrixTransform(matrix?:DOMMatrixInit):DOMPoint;toJSON():any ;}declare var DOMPointReadOnly:{prototype:DOMPointReadOnly;new (x?:number ,y?:number ,z?:number ,w?:number ):DOMPointReadOnly;fromPoint(other?:DOMPointInit):DOMPointReadOnly;};interface DOMQuad{readonly p1:DOMPoint;readonly p2:DOMPoint;readonly p3:DOMPoint;readonly p4:DOMPoint;getBounds():DOMRect;toJSON():any ;}declare var DOMQuad:{prototype:DOMQuad;new (p1?:DOMPointInit,p2?:DOMPointInit,p3?:DOMPointInit,p4?:DOMPointInit):DOMQuad;fromQuad(other?:DOMQuadInit):DOMQuad;fromRect(other?:DOMRectInit):DOMQuad;};interface DOMRectextends DOMRectReadOnly{height:number ;width:number ;x:number ;y:number ;}declare var DOMRect:{prototype:DOMRect;new (x?:number ,y?:number ,width?:number ,height?:number ):DOMRect;fromRect(other?:DOMRectInit):DOMRect;};interface DOMRectReadOnly{readonly bottom:number ;readonly height:number ;readonly left:number ;readonly right:number ;readonly top:number ;readonly width:number ;readonly x:number ;readonly y:number ;toJSON():any ;}declare var DOMRectReadOnly:{prototype:DOMRectReadOnly;new (x?:number ,y?:number ,width?:number ,height?:number ):DOMRectReadOnly;fromRect(other?:DOMRectInit):DOMRectReadOnly;};interface DOMStringList{/**\n * Returns the number of strings in strings.\n */readonly length:number ;/**\n * Returns true if strings contains string, and false\n * otherwise.\n */contains(string :string ):boolean ;/**\n * Returns the string with index index from strings.\n */item(index:number ):string |null ;[index:number ]:string ;}declare var DOMStringList:{prototype:DOMStringList;new ():DOMStringList;};interface DedicatedWorkerGlobalScopeEventMapextends WorkerGlobalScopeEventMap{"message":MessageEvent;}interface DedicatedWorkerGlobalScopeextends WorkerGlobalScope{onmessage:((this :DedicatedWorkerGlobalScope,ev:MessageEvent)=>any )|null ;close():void ;postMessage(message:any ,transfer?:any []):void ;addEventListener<Kextends keyof DedicatedWorkerGlobalScopeEventMap>(type :K,listener:(this :DedicatedWorkerGlobalScope,ev:DedicatedWorkerGlobalScopeEventMap[K])=>any ,options?:boolean |AddEventListenerOptions):void ;addEventListener(type :string ,listener:EventListenerOrEventListenerObject,options?:boolean |AddEventListenerOptions):void ;removeEventListener<Kextends keyof DedicatedWorkerGlobalScopeEventMap>(type :K,listener:(this :DedicatedWorkerGlobalScope,ev:DedicatedWorkerGlobalScopeEventMap[K])=>any ,options?:boolean |EventListenerOptions):void ;removeEventListener(type :string ,listener:EventListenerOrEventListenerObject,options?:boolean |EventListenerOptions):void ;}declare var DedicatedWorkerGlobalScope:{prototype:DedicatedWorkerGlobalScope;new ():DedicatedWorkerGlobalScope;};interface DhImportKeyParamsextends Algorithm{generator:Uint8Array;prime:Uint8Array;}interface DhKeyAlgorithmextends KeyAlgorithm{generator:Uint8Array;prime:Uint8Array;}interface DhKeyDeriveParamsextends Algorithm{public :CryptoKey;}interface DhKeyGenParamsextends Algorithm{generator:Uint8Array;prime:Uint8Array;}interface ErrorEventextends Event{readonly colno:number ;readonly error:any ;readonly filename:string ;readonly lineno:number ;readonly message:string ;initErrorEvent(typeArg:string ,canBubbleArg:boolean ,cancelableArg:boolean ,messageArg:string ,filenameArg:string ,linenoArg:number ):void ;}declare var ErrorEvent:{prototype:ErrorEvent;new (typeArg:string ,eventInitDict?:ErrorEventInit):ErrorEvent;};interface Event{readonly bubbles:boolean ;cancelBubble:boolean ;readonly cancelable:boolean ;readonly composed:boolean ;readonly currentTarget:EventTarget|null ;readonly defaultPrevented:boolean ;readonly eventPhase:number ;readonly isTrusted:boolean ;returnValue:boolean ;readonly srcElement:object |null ;readonly target:EventTarget|null ;readonly timeStamp:number ;readonly type :string ;deepPath():EventTarget[];initEvent(type :string ,bubbles?:boolean ,cancelable?:boolean ):void ;preventDefault():void ;stopImmediatePropagation():void ;stopPropagation():void ;readonly AT_TARGET:number ;readonly BUBBLING_PHASE:number ;readonly CAPTURING_PHASE:number ;readonly NONE:number ;}declare var Event:{prototype:Event;new (typeArg:string ,eventInitDict?:EventInit):Event;readonly AT_TARGET:number ;readonly BUBBLING_PHASE:number ;readonly CAPTURING_PHASE:number ;readonly NONE:number ;};interface EventListenerObject{handleEvent(evt:Event):void ;}interface EventSourceextends EventTarget{readonly CLOSED:number ;readonly CONNECTING:number ;readonly OPEN:number ;onerror:(evt:MessageEvent)=>any ;onmessage:(evt:MessageEvent)=>any ;onopen:(evt:MessageEvent)=>any ;readonly readyState:number ;readonly url:string ;readonly withCredentials:boolean ;close():void ;}declare var EventSource:{prototype:EventSource;new (url:string ,eventSourceInitDict?:EventSourceInit):EventSource;};interface EventSourceInit{readonly withCredentials:boolean ;}interface EventTarget{addEventListener(type :string ,listener:EventListenerOrEventListenerObject|null ,options?:boolean |AddEventListenerOptions):void ;dispatchEvent(evt:Event):boolean ;removeEventListener(type :string ,listener?:EventListenerOrEventListenerObject|null ,options?:EventListenerOptions|boolean ):void ;}declare var EventTarget:{prototype:EventTarget;new ():EventTarget;};interface ExtendableEventextends Event{waitUntil(f:Promise<any >):void ;}declare var ExtendableEvent:{prototype:ExtendableEvent;new (type :string ,eventInitDict?:ExtendableEventInit):ExtendableEvent;};interface ExtendableMessageEventextends ExtendableEvent{readonly data:any ;readonly lastEventId:string ;readonly origin:string ;readonly ports:ReadonlyArray<MessagePort>;readonly source:Client|ServiceWorker|MessagePort|null ;}declare var ExtendableMessageEvent:{prototype:ExtendableMessageEvent;new (type :string ,eventInitDict?:ExtendableMessageEventInit):ExtendableMessageEvent;};interface FetchEventextends ExtendableEvent{readonly clientId:string ;readonly preloadResponse:Promise<any >;readonly request:Request;readonly resultingClientId:string ;readonly targetClientId:string ;respondWith(r:Promise<Response>):void ;}declare var FetchEvent:{prototype:FetchEvent;new (type :string ,eventInitDict:FetchEventInit):FetchEvent;};interface Fileextends Blob{readonly lastModified:number ;readonly name:string ;}declare var File:{prototype:File;new (fileBits:BlobPart[],fileName:string ,options?:FilePropertyBag):File;};interface FileList{readonly length:number ;item(index:number ):File|null ;[index:number ]:File;}declare var FileList:{prototype:FileList;new ():FileList;};interface FileReaderEventMap{"abort":ProgressEvent;"error":ProgressEvent;"load":ProgressEvent;"loadend":ProgressEvent;"loadstart":ProgressEvent;"progress":ProgressEvent;}interface FileReaderextends EventTarget{readonly error:DOMException|null ;onabort:((this :FileReader,ev:ProgressEvent)=>any )|null ;onerror:((this :FileReader,ev:ProgressEvent)=>any )|null ;onload:((this :FileReader,ev:ProgressEvent)=>any )|null ;onloadend:((this :FileReader,ev:ProgressEvent)=>any )|null ;onloadstart:((this :FileReader,ev:ProgressEvent)=>any )|null ;onprogress:((this :FileReader,ev:ProgressEvent)=>any )|null ;readonly readyState:number ;readonly result:string |ArrayBuffer|null ;abort():void ;readAsArrayBuffer(blob:Blob):void ;readAsBinaryString(blob:Blob):void ;readAsDataURL(blob:Blob):void ;readAsText(blob:Blob,label?:string ):void ;readonly DONE:number ;readonly EMPTY:number ;readonly LOADING:number ;addEventListener<Kextends keyof FileReaderEventMap>(type :K,listener:(this :FileReader,ev:FileReaderEventMap[K])=>any ,options?:boolean |AddEventListenerOptions):void ;addEventListener(type :string ,listener:EventListenerOrEventListenerObject,options?:boolean |AddEventListenerOptions):void ;removeEventListener<Kextends keyof FileReaderEventMap>(type :K,listener:(this :FileReader,ev:FileReaderEventMap[K])=>any ,options?:boolean |EventListenerOptions):void ;removeEventListener(type :string ,listener:EventListenerOrEventListenerObject,options?:boolean |EventListenerOptions):void ;}declare var FileReader:{prototype:FileReader;new ():FileReader;readonly DONE:number ;readonly EMPTY:number ;readonly LOADING:number ;};interface FileReaderSync{readAsArrayBuffer(blob:Blob):ArrayBuffer;readAsBinaryString(blob:Blob):string ;readAsDataURL(blob:Blob):string ;readAsText(blob:Blob,label?:string ):string ;}declare var FileReaderSync:{prototype:FileReaderSync;new ():FileReaderSync;};interface FormData{append(name:string ,value:string |Blob,fileName?:string ):void ;delete (name:string ):void ;get (name:string ):FormDataEntryValue|null ;getAll(name:string ):FormDataEntryValue[];has(name:string ):boolean ;set (name:string ,value:string |Blob,fileName?:string ):void ;forEach(callbackfn:(value:FormDataEntryValue,key:string ,parent:FormData)=>void ,thisArg?:any ):void ;}declare var FormData:{prototype:FormData;new (form?:object ):FormData;};interface GlobalFetch{fetch(input?:Request|string ,init?:RequestInit):Promise<Response>;}interface Headers{append(name:string ,value:string ):void ;delete (name:string ):void ;get (name:string ):string |null ;has(name:string ):boolean ;set (name:string ,value:string ):void ;forEach(callbackfn:(value:string ,key:string ,parent:Headers)=>void ,thisArg?:any ):void ;}declare var Headers:{prototype:Headers;new (init?:HeadersInit):Headers;};interface HkdfCtrParamsextends Algorithm{context:Int8Array|Int16Array|Int32Array|Uint8Array|Uint16Array|Uint32Array|Uint8ClampedArray|Float32Array|Float64Array|DataView|ArrayBuffer;hash:string |Algorithm;label:Int8Array|Int16Array|Int32Array|Uint8Array|Uint16Array|Uint32Array|Uint8ClampedArray|Float32Array|Float64Array|DataView|ArrayBuffer;}interface IDBArrayKeyextends Array<IDBValidKey>{}interface IDBCursor{/**\n * Returns the direction ("next", "nextunique", "prev" or "prevunique")\n * of the cursor.\n */readonly direction:IDBCursorDirection;/**\n * Returns the key of the cursor.\n * Throws a "InvalidStateError" DOMException if the cursor is advancing or is finished.\n */readonly key:IDBValidKey|IDBKeyRange;/**\n * Returns the effective key of the cursor.\n * Throws a "InvalidStateError" DOMException if the cursor is advancing or is finished.\n */readonly primaryKey:IDBValidKey|IDBKeyRange;/**\n * Returns the IDBObjectStore or IDBIndex the cursor was opened from.\n */readonly source:IDBObjectStore|IDBIndex;/**\n * Advances the cursor through the next count records in\n * range.\n */advance(count:number ):void ;/**\n * Advances the cursor to the next record in range matching or\n * after key.\n */continue (key?:IDBValidKey|IDBKeyRange):void ;/**\n * Advances the cursor to the next record in range matching\n * or after key and primaryKey. Throws an "InvalidAccessError" DOMException if the source is not an index.\n */continuePrimaryKey(key:IDBValidKey|IDBKeyRange,primaryKey:IDBValidKey|IDBKeyRange):void ;/**\n * Delete the record pointed at by the cursor with a new value.\n * If successful, request's result will be undefined.\n */delete ():IDBRequest;/**\n * Updated the record pointed at by the cursor with a new value.\n * Throws a "DataError" DOMException if the effective object store uses in-line keys and the key would have changed.\n * If successful, request's result will be the record's key.\n */update(value:any ):IDBRequest;}declare var IDBCursor:{prototype:IDBCursor;new ():IDBCursor;};interface IDBCursorWithValueextends IDBCursor{/**\n * Returns the cursor's current value.\n */readonly value:any ;}declare var IDBCursorWithValue:{prototype:IDBCursorWithValue;new ():IDBCursorWithValue;};interface IDBDatabaseEventMap{"abort":Event;"close":Event;"error":Event;"versionchange":IDBVersionChangeEvent;}interface IDBDatabaseextends EventTarget{/**\n * Returns the name of the database.\n */readonly name:string ;/**\n * Returns a list of the names of object stores in the database.\n */readonly objectStoreNames:DOMStringList;onabort:((this :IDBDatabase,ev:Event)=>any )|null ;onclose:((this :IDBDatabase,ev:Event)=>any )|null ;onerror:((this :IDBDatabase,ev:Event)=>any )|null ;onversionchange:((this :IDBDatabase,ev:IDBVersionChangeEvent)=>any )|null ;/**\n * Returns the version of the database.\n */readonly version:number ;/**\n * Closes the connection once all running transactions have finished.\n */close():void ;/**\n * Creates a new object store with the given name and options and returns a new IDBObjectStore.\n * Throws a "InvalidStateError" DOMException if not called within an upgrade transaction.\n */createObjectStore(name:string ,optionalParameters?:IDBObjectStoreParameters):IDBObjectStore;/**\n * Deletes the object store with the given name.\n * Throws a "InvalidStateError" DOMException if not called within an upgrade transaction.\n */deleteObjectStore(name:string ):void ;/**\n * Returns a new transaction with the given mode ("readonly" or "readwrite")\n * and scope which can be a single object store name or an array of names.\n */transaction(storeNames:string |string [],mode?:IDBTransactionMode):IDBTransaction;addEventListener<Kextends keyof IDBDatabaseEventMap>(type :K,listener:(this :IDBDatabase,ev:IDBDatabaseEventMap[K])=>any ,options?:boolean |AddEventListenerOptions):void ;addEventListener(type :string ,listener:EventListenerOrEventListenerObject,options?:boolean |AddEventListenerOptions):void ;removeEventListener<Kextends keyof IDBDatabaseEventMap>(type :K,listener:(this :IDBDatabase,ev:IDBDatabaseEventMap[K])=>any ,options?:boolean |EventListenerOptions):void ;removeEventListener(type :string ,listener:EventListenerOrEventListenerObject,options?:boolean |EventListenerOptions):void ;}declare var IDBDatabase:{prototype:IDBDatabase;new ():IDBDatabase;};interface IDBFactory{/**\n * Compares two values as keys. Returns -1 if key1 precedes key2, 1 if key2 precedes key1, and 0 if\n * the keys are equal.\n * Throws a "DataError" DOMException if either input is not a valid key.\n */cmp(first:any ,second:any ):number ;/**\n * Attempts to delete the named database. If the\n * database already exists and there are open connections that don't close in response to a versionchange event, the request will be blocked until all they close. If the request\n * is successful request's result will be null.\n */deleteDatabase(name:string ):IDBOpenDBRequest;/**\n * Attempts to open a connection to the named database with the specified version. If the database already exists\n * with a lower version and there are open connections that don't close in response to a versionchange event, the request will be blocked until all they close, then an upgrade\n * will occur. If the database already exists with a higher\n * version the request will fail. If the request is\n * successful request's result will\n * be the connection.\n */open(name:string ,version?:number ):IDBOpenDBRequest;}declare var IDBFactory:{prototype:IDBFactory;new ():IDBFactory;};interface IDBIndex{readonly keyPath:string |string [];readonly multiEntry:boolean ;/**\n * Updates the name of the store to newName.\n * Throws an "InvalidStateError" DOMException if not called within an upgrade\n * transaction.\n */name:string ;/**\n * Returns the IDBObjectStore the index belongs to.\n */readonly objectStore:IDBObjectStore;readonly unique :boolean ;/**\n * Retrieves the number of records matching the given key or key range in query.\n * If successful, request's result will be the\n * count.\n */count(key?:IDBValidKey|IDBKeyRange):IDBRequest;/**\n * Retrieves the value of the first record matching the\n * given key or key range in query.\n * If successful, request's result will be the value, or undefined if there was no matching record.\n */get (key:IDBValidKey|IDBKeyRange):IDBRequest;/**\n * Retrieves the values of the records matching the given key or key range in query (up to count if given).\n * If successful, request's result will be an Array of the values.\n */getAll(query?:IDBValidKey|IDBKeyRange,count?:number ):IDBRequest;/**\n * Retrieves the keys of records matching the given key or key range in query (up to count if given).\n * If successful, request's result will be an Array of the keys.\n */getAllKeys(query?:IDBValidKey|IDBKeyRange,count?:number ):IDBRequest;/**\n * Retrieves the key of the first record matching the\n * given key or key range in query.\n * If successful, request's result will be the key, or undefined if there was no matching record.\n */getKey(key:IDBValidKey|IDBKeyRange):IDBRequest;/**\n * Opens a cursor over the records matching query,\n * ordered by direction. If query is null, all records in index are matched.\n * If successful, request's result will be an IDBCursorWithValue, or null if there were no matching records.\n */openCursor(range?:IDBValidKey|IDBKeyRange,direction?:IDBCursorDirection):IDBRequest;/**\n * Opens a cursor with key only flag set over the records matching query, ordered by direction. If query is null, all records in index are matched.\n * If successful, request's result will be an IDBCursor, or null if there were no matching records.\n */openKeyCursor(range?:IDBValidKey|IDBKeyRange,direction?:IDBCursorDirection):IDBRequest;}declare var IDBIndex:{prototype:IDBIndex;new ():IDBIndex;};interface IDBKeyRange{/**\n * Returns lower bound, or undefined if none.\n */readonly lower:any ;/**\n * Returns true if the lower open flag is set, and false otherwise.\n */readonly lowerOpen:boolean ;/**\n * Returns upper bound, or undefined if none.\n */readonly upper:any ;/**\n * Returns true if the upper open flag is set, and false otherwise.\n */readonly upperOpen:boolean ;/**\n * Returns true if key is included in the range, and false otherwise.\n */includes(key:any ):boolean ;}declare var IDBKeyRange:{prototype:IDBKeyRange;new ():IDBKeyRange;/**\n * Returns a new IDBKeyRange spanning from lower to upper.\n * If lowerOpen is true, lower is not included in the range.\n * If upperOpen is true, upper is not included in the range.\n */bound(lower:any ,upper:any ,lowerOpen?:boolean ,upperOpen?:boolean ):IDBKeyRange;/**\n * Returns a new IDBKeyRange starting at key with no\n * upper bound. If open is true, key is not included in the\n * range.\n */lowerBound(lower:any ,open?:boolean ):IDBKeyRange;/**\n * Returns a new IDBKeyRange spanning only key.\n */only(value:any ):IDBKeyRange;/**\n * Returns a new IDBKeyRange with no lower bound and ending at key. If open is true, key is not included in the range.\n */upperBound(upper:any ,open?:boolean ):IDBKeyRange;};interface IDBObjectStore{/**\n * Returns true if the store has a key generator, and false otherwise.\n */readonly autoIncrement:boolean ;/**\n * Returns a list of the names of indexes in the store.\n */readonly indexNames:DOMStringList;/**\n * Returns the key path of the store, or null if none.\n */readonly keyPath:string |string [];/**\n * Updates the name of the store to newName.\n * Throws "InvalidStateError" DOMException if not called within an upgrade\n * transaction.\n */name:string ;/**\n * Returns the associated transaction.\n */readonly transaction:IDBTransaction;add(value:any ,key?:IDBValidKey|IDBKeyRange):IDBRequest;/**\n * Deletes all records in store.\n * If successful, request's result will\n * be undefined.\n */clear():IDBRequest;/**\n * Retrieves the number of records matching the\n * given key or key range in query.\n * If successful, request's result will be the count.\n */count(key?:IDBValidKey|IDBKeyRange):IDBRequest;/**\n * Creates a new index in store with the given name, keyPath and options and returns a new IDBIndex. If the keyPath and options define constraints that cannot be\n * satisfied with the data already in store the upgrade\n * transaction will abort with\n * a "ConstraintError" DOMException.\n * Throws an "InvalidStateError" DOMException if not called within an upgrade\n * transaction.\n */createIndex(name:string ,keyPath:string |string [],options?:IDBIndexParameters):IDBIndex;/**\n * Deletes records in store with the given key or in the given key range in query.\n * If successful, request's result will\n * be undefined.\n */delete (key:IDBValidKey|IDBKeyRange):IDBRequest;/**\n * Deletes the index in store with the given name.\n * Throws an "InvalidStateError" DOMException if not called within an upgrade\n * transaction.\n */deleteIndex(name:string ):void ;/**\n * Retrieves the value of the first record matching the\n * given key or key range in query.\n * If successful, request's result will be the value, or undefined if there was no matching record.\n */get (query:IDBValidKey|IDBKeyRange):IDBRequest;/**\n * Retrieves the values of the records matching the\n * given key or key range in query (up to count if given).\n * If successful, request's result will\n * be an Array of the values.\n */getAll(query?:IDBValidKey|IDBKeyRange,count?:number ):IDBRequest;/**\n * Retrieves the keys of records matching the\n * given key or key range in query (up to count if given).\n * If successful, request's result will\n * be an Array of the keys.\n */getAllKeys(query?:IDBValidKey|IDBKeyRange,count?:number ):IDBRequest;/**\n * Retrieves the key of the first record matching the\n * given key or key range in query.\n * If successful, request's result will be the key, or undefined if there was no matching record.\n */getKey(query:IDBValidKey|IDBKeyRange):IDBRequest;index(name:string ):IDBIndex;/**\n * Opens a cursor over the records matching query,\n * ordered by direction. If query is null, all records in store are matched.\n * If successful, request's result will be an IDBCursorWithValue pointing at the first matching record, or null if there were no matching records.\n */openCursor(range?:IDBValidKey|IDBKeyRange,direction?:IDBCursorDirection):IDBRequest;/**\n * Opens a cursor with key only flag set over the records matching query, ordered by direction. If query is null, all records in store are matched.\n * If successful, request's result will be an IDBCursor pointing at the first matching record, or\n * null if there were no matching records.\n */openKeyCursor(query?:IDBValidKey|IDBKeyRange,direction?:IDBCursorDirection):IDBRequest;put(value:any ,key?:IDBValidKey|IDBKeyRange):IDBRequest;}declare var IDBObjectStore:{prototype:IDBObjectStore;new ():IDBObjectStore;};interface IDBOpenDBRequestEventMapextends IDBRequestEventMap{"blocked":Event;"upgradeneeded":IDBVersionChangeEvent;}interface IDBOpenDBRequestextends IDBRequest{onblocked:((this :IDBOpenDBRequest,ev:Event)=>any )|null ;onupgradeneeded:((this :IDBOpenDBRequest,ev:IDBVersionChangeEvent)=>any )|null ;addEventListener<Kextends keyof IDBOpenDBRequestEventMap>(type :K,listener:(this :IDBOpenDBRequest,ev:IDBOpenDBRequestEventMap[K])=>any ,options?:boolean |AddEventListenerOptions):void ;addEventListener(type :string ,listener:EventListenerOrEventListenerObject,options?:boolean |AddEventListenerOptions):void ;removeEventListener<Kextends keyof IDBOpenDBRequestEventMap>(type :K,listener:(this :IDBOpenDBRequest,ev:IDBOpenDBRequestEventMap[K])=>any ,options?:boolean |EventListenerOptions):void ;removeEventListener(type :string ,listener:EventListenerOrEventListenerObject,options?:boolean |EventListenerOptions):void ;}declare var IDBOpenDBRequest:{prototype:IDBOpenDBRequest;new ():IDBOpenDBRequest;};interface IDBRequestEventMap{"error":Event;"success":Event;}interface IDBRequestextends EventTarget{/**\n * When a request is completed, returns the error (a DOMException), or null if the request succeeded. Throws\n * a "InvalidStateError" DOMException if the request is still pending.\n */readonly error:DOMException|null ;onerror:((this :IDBRequest,ev:Event)=>any )|null ;onsuccess:((this :IDBRequest,ev:Event)=>any )|null ;/**\n * Returns "pending" until a request is complete,\n * then returns "done".\n */readonly readyState:IDBRequestReadyState;/**\n * When a request is completed, returns the result,\n * or undefined if the request failed. Throws a\n * "InvalidStateError" DOMException if the request is still pending.\n */readonly result:any ;/**\n * Returns the IDBObjectStore, IDBIndex, or IDBCursor the request was made against, or null if is was an open\n * request.\n */readonly source:IDBObjectStore|IDBIndex|IDBCursor;/**\n * Returns the IDBTransaction the request was made within.\n * If this as an open request, then it returns an upgrade transaction while it is running, or null otherwise.\n */readonly transaction:IDBTransaction|null ;addEventListener<Kextends keyof IDBRequestEventMap>(type :K,listener:(this :IDBRequest,ev:IDBRequestEventMap[K])=>any ,options?:boolean |AddEventListenerOptions):void ;addEventListener(type :string ,listener:EventListenerOrEventListenerObject,options?:boolean |AddEventListenerOptions):void ;removeEventListener<Kextends keyof IDBRequestEventMap>(type :K,listener:(this :IDBRequest,ev:IDBRequestEventMap[K])=>any ,options?:boolean |EventListenerOptions):void ;removeEventListener(type :string ,listener:EventListenerOrEventListenerObject,options?:boolean |EventListenerOptions):void ;}declare var IDBRequest:{prototype:IDBRequest;new ():IDBRequest;};interface IDBTransactionEventMap{"abort":Event;"complete":Event;"error":Event;}interface IDBTransactionextends EventTarget{/**\n * Returns the transaction's connection.\n */readonly db:IDBDatabase;/**\n * If the transaction was aborted, returns the\n * error (a DOMException) providing the reason.\n */readonly error:DOMException;/**\n * Returns the mode the transaction was created with\n * ("readonly" or "readwrite"), or "versionchange" for\n * an upgrade transaction.\n */readonly mode:IDBTransactionMode;/**\n * Returns a list of the names of object stores in the\n * transaction's scope. For an upgrade transaction this is all object stores in the database.\n */readonly objectStoreNames:DOMStringList;onabort:((this :IDBTransaction,ev:Event)=>any )|null ;oncomplete:((this :IDBTransaction,ev:Event)=>any )|null ;onerror:((this :IDBTransaction,ev:Event)=>any )|null ;/**\n * Aborts the transaction. All pending requests will fail with\n * a "AbortError" DOMException and all changes made to the database will be\n * reverted.\n */abort():void ;/**\n * Returns an IDBObjectStore in the transaction's scope.\n */objectStore(name:string ):IDBObjectStore;addEventListener<Kextends keyof IDBTransactionEventMap>(type :K,listener:(this :IDBTransaction,ev:IDBTransactionEventMap[K])=>any ,options?:boolean |AddEventListenerOptions):void ;addEventListener(type :string ,listener:EventListenerOrEventListenerObject,options?:boolean |AddEventListenerOptions):void ;removeEventListener<Kextends keyof IDBTransactionEventMap>(type :K,listener:(this :IDBTransaction,ev:IDBTransactionEventMap[K])=>any ,options?:boolean |EventListenerOptions):void ;removeEventListener(type :string ,listener:EventListenerOrEventListenerObject,options?:boolean |EventListenerOptions):void ;}declare var IDBTransaction:{prototype:IDBTransaction;new ():IDBTransaction;};interface IDBVersionChangeEventextends Event{readonly newVersion:number |null ;readonly oldVersion:number ;}declare var IDBVersionChangeEvent:{prototype:IDBVersionChangeEvent;new (type :string ,eventInitDict?:IDBVersionChangeEventInit):IDBVersionChangeEvent;};interface ImageBitmap{readonly height:number ;readonly width:number ;close():void ;}interface ImageBitmapOptions{colorSpaceConversion?:"none"|"default";imageOrientation?:"none"|"flipY";premultiplyAlpha?:"none"|"premultiply"|"default";resizeHeight?:number ;resizeQuality?:"pixelated"|"low"|"medium"|"high";resizeWidth?:number ;}interface ImageData{}declare var ImageData:{prototype:ImageData;new (width:number ,height:number ):ImageData;new (array:Uint8ClampedArray,width:number ,height:number ):ImageData;};interface MessageChannel{readonly port1:MessagePort;readonly port2:MessagePort;}declare var MessageChannel:{prototype:MessageChannel;new ():MessageChannel;};interface MessageEventextends Event{readonly data:any ;readonly origin:string ;readonly ports:ReadonlyArray<MessagePort>;readonly source:MessageEventSource;initMessageEvent(type :string ,bubbles:boolean ,cancelable:boolean ,data:any ,origin:string ,lastEventId:string ,source:object ):void ;}declare var MessageEvent:{prototype:MessageEvent;new (type :string ,eventInitDict?:MessageEventInit):MessageEvent;};interface MessagePortEventMap{"message":MessageEvent;"messageerror":MessageEvent;}interface MessagePortextends EventTarget{onmessage:((this :MessagePort,ev:MessageEvent)=>any )|null ;onmessageerror:((this :MessagePort,ev:MessageEvent)=>any )|null ;/**\n * Disconnects the port, so that it is no longer active.\n */close():void ;/**\n * Posts a message through the channel. Objects listed in transfer are\n * transferred, not just cloned, meaning that they are no longer usable on the sending side.\n * Throws a "DataCloneError" DOMException if\n * transfer contains duplicate objects or port, or if message\n * could not be cloned.\n */postMessage(message:any ,transfer?:any []):void ;/**\n * Begins dispatching messages received on the port.\n */start():void ;addEventListener<Kextends keyof MessagePortEventMap>(type :K,listener:(this :MessagePort,ev:MessagePortEventMap[K])=>any ,options?:boolean |AddEventListenerOptions):void ;addEventListener(type :string ,listener:EventListenerOrEventListenerObject,options?:boolean |AddEventListenerOptions):void ;removeEventListener<Kextends keyof MessagePortEventMap>(type :K,listener:(this :MessagePort,ev:MessagePortEventMap[K])=>any ,options?:boolean |EventListenerOptions):void ;removeEventListener(type :string ,listener:EventListenerOrEventListenerObject,options?:boolean |EventListenerOptions):void ;}declare var MessagePort:{prototype:MessagePort;new ():MessagePort;};interface NavigationPreloadManager{disable():Promise<void >;enable():Promise<void >;getState():Promise<NavigationPreloadState>;setHeaderValue(value:string ):Promise<void >;}declare var NavigationPreloadManager:{prototype:NavigationPreloadManager;new ():NavigationPreloadManager;};interface NavigatorBeacon{sendBeacon(url:string ,data?:Blob|Int8Array|Int16Array|Int32Array|Uint8Array|Uint16Array|Uint32Array|Uint8ClampedArray|Float32Array|Float64Array|DataView|ArrayBuffer|FormData|string |null ):boolean ;}interface NavigatorConcurrentHardware{readonly hardwareConcurrency:number ;}interface NavigatorID{readonly appCodeName:string ;readonly appName:string ;readonly appVersion:string ;readonly platform:string ;readonly product:string ;readonly productSub:string ;readonly userAgent:string ;readonly vendor:string ;readonly vendorSub:string ;}interface NavigatorOnLine{readonly onLine:boolean ;}interface NavigatorStorage{readonly storage:StorageManager;}interface NotificationEventMap{"click":Event;"close":Event;"error":Event;"show":Event;}interface Notificationextends EventTarget{readonly actions:ReadonlyArray<NotificationAction>;readonly badge:string ;readonly body:string ;readonly data:any ;readonly dir:NotificationDirection;readonly icon:string ;readonly image:string ;readonly lang:string ;onclick:((this :Notification,ev:Event)=>any )|null ;onclose:((this :Notification,ev:Event)=>any )|null ;onerror:((this :Notification,ev:Event)=>any )|null ;onshow:((this :Notification,ev:Event)=>any )|null ;readonly renotify:boolean ;readonly requireInteraction:boolean ;readonly silent:boolean ;readonly tag:string ;readonly timestamp:number ;readonly title:string ;readonly vibrate:ReadonlyArray<number >;close():void ;addEventListener<Kextends keyof NotificationEventMap>(type :K,listener:(this :Notification,ev:NotificationEventMap[K])=>any ,options?:boolean |AddEventListenerOptions):void ;addEventListener(type :string ,listener:EventListenerOrEventListenerObject,options?:boolean |AddEventListenerOptions):void ;removeEventListener<Kextends keyof NotificationEventMap>(type :K,listener:(this :Notification,ev:NotificationEventMap[K])=>any ,options?:boolean |EventListenerOptions):void ;removeEventListener(type :string ,listener:EventListenerOrEventListenerObject,options?:boolean |EventListenerOptions):void ;}declare var Notification:{prototype:Notification;new (title:string ,options?:NotificationOptions):Notification;readonly maxActions:number ;readonly permission:NotificationPermission;};interface NotificationEventextends ExtendableEvent{readonly action:string ;readonly notification:Notification;}declare var NotificationEvent:{prototype:NotificationEvent;new (type :string ,eventInitDict:NotificationEventInit):NotificationEvent;};interface PerformanceEventMap{"resourcetimingbufferfull":Event;}interface Performanceextends EventTarget{onresourcetimingbufferfull:((this :Performance,ev:Event)=>any )|null ;readonly timeOrigin:number ;clearMarks(markName?:string ):void ;clearMeasures(measureName?:string ):void ;clearResourceTimings():void ;getEntries():PerformanceEntryList;getEntriesByName(name:string ,type ?:string ):PerformanceEntryList;getEntriesByType(type :string ):PerformanceEntryList;mark(markName:string ):void ;measure(measureName:string ,startMark?:string ,endMark?:string ):void ;now():number ;setResourceTimingBufferSize(maxSize:number ):void ;toJSON():any ;addEventListener<Kextends keyof PerformanceEventMap>(type :K,listener:(this :Performance,ev:PerformanceEventMap[K])=>any ,options?:boolean |AddEventListenerOptions):void ;addEventListener(type :string ,listener:EventListenerOrEventListenerObject,options?:boolean |AddEventListenerOptions):void ;removeEventListener<Kextends keyof PerformanceEventMap>(type :K,listener:(this :Performance,ev:PerformanceEventMap[K])=>any ,options?:boolean |EventListenerOptions):void ;removeEventListener(type :string ,listener:EventListenerOrEventListenerObject,options?:boolean |EventListenerOptions):void ;}declare var Performance:{prototype:Performance;new ():Performance;};interface PerformanceEntry{readonly duration:number ;readonly entryType:string ;readonly name:string ;readonly startTime:number ;toJSON():any ;}declare var PerformanceEntry:{prototype:PerformanceEntry;new ():PerformanceEntry;};interface PerformanceMarkextends PerformanceEntry{}declare var PerformanceMark:{prototype:PerformanceMark;new ():PerformanceMark;};interface PerformanceMeasureextends PerformanceEntry{}declare var PerformanceMeasure:{prototype:PerformanceMeasure;new ():PerformanceMeasure;};interface PerformanceObserver{disconnect():void ;observe(options:PerformanceObserverInit):void ;takeRecords():PerformanceEntryList;}declare var PerformanceObserver:{prototype:PerformanceObserver;new (callback:PerformanceObserverCallback):PerformanceObserver;};interface PerformanceObserverEntryList{getEntries():PerformanceEntryList;getEntriesByName(name:string ,type ?:string ):PerformanceEntryList;getEntriesByType(type :string ):PerformanceEntryList;}declare var PerformanceObserverEntryList:{prototype:PerformanceObserverEntryList;new ():PerformanceObserverEntryList;};interface PerformanceResourceTimingextends PerformanceEntry{readonly connectEnd:number ;readonly connectStart:number ;readonly decodedBodySize:number ;readonly domainLookupEnd:number ;readonly domainLookupStart:number ;readonly encodedBodySize:number ;readonly fetchStart:number ;readonly initiatorType:string ;readonly nextHopProtocol:string ;readonly redirectEnd:number ;readonly redirectStart:number ;readonly requestStart:number ;readonly responseEnd:number ;readonly responseStart:number ;readonly secureConnectionStart:number ;readonly transferSize:number ;readonly workerStart:number ;toJSON():any ;}declare var PerformanceResourceTiming:{prototype:PerformanceResourceTiming;new ():PerformanceResourceTiming;};interface ProgressEventextends Event{readonly lengthComputable:boolean ;readonly loaded:number ;readonly total:number ;}declare var ProgressEvent:{prototype:ProgressEvent;new (type :string ,eventInitDict?:ProgressEventInit):ProgressEvent;};interface PromiseRejectionEventextends Event{readonly promise:PromiseLike<any >;readonly reason:any ;}declare var PromiseRejectionEvent:{prototype:PromiseRejectionEvent;new (type :string ,eventInitDict:PromiseRejectionEventInit):PromiseRejectionEvent;};interface PushEventextends ExtendableEvent{readonly data:PushMessageData|null ;}declare var PushEvent:{prototype:PushEvent;new (type :string ,eventInitDict?:PushEventInit):PushEvent;};interface PushManager{getSubscription():Promise<PushSubscription|null >;permissionState(options?:PushSubscriptionOptionsInit):Promise<PushPermissionState>;subscribe(options?:PushSubscriptionOptionsInit):Promise<PushSubscription>;}declare var PushManager:{prototype:PushManager;new ():PushManager;readonly supportedContentEncodings:ReadonlyArray<string >;};interface PushMessageData{arrayBuffer():ArrayBuffer;blob():Blob;json():any ;text():string ;}declare var PushMessageData:{prototype:PushMessageData;new ():PushMessageData;};interface PushSubscription{readonly endpoint:string ;readonly expirationTime:number |null ;readonly options:PushSubscriptionOptions;getKey(name:PushEncryptionKeyName):ArrayBuffer|null ;toJSON():PushSubscriptionJSON;unsubscribe():Promise<boolean >;}declare var PushSubscription:{prototype:PushSubscription;new ():PushSubscription;};interface PushSubscriptionChangeEventextends ExtendableEvent{readonly newSubscription:PushSubscription|null ;readonly oldSubscription:PushSubscription|null ;}declare var PushSubscriptionChangeEvent:{prototype:PushSubscriptionChangeEvent;new (type :string ,eventInitDict?:PushSubscriptionChangeInit):PushSubscriptionChangeEvent;};interface PushSubscriptionOptions{readonly applicationServerKey:ArrayBuffer|null ;readonly userVisibleOnly:boolean ;}declare var PushSubscriptionOptions:{prototype:PushSubscriptionOptions;new ():PushSubscriptionOptions;};interface ReadableStream{readonly locked:boolean ;cancel():Promise<void >;getReader():ReadableStreamReader;}declare var ReadableStream:{prototype:ReadableStream;new ():ReadableStream;};interface ReadableStreamReader{cancel():Promise<void >;read():Promise<any >;releaseLock():void ;}declare var ReadableStreamReader:{prototype:ReadableStreamReader;new ():ReadableStreamReader;};interface Requestextends Body{/**\n * Returns the cache mode associated with request, which is a string indicating\n * how the the request will interact with the browser's cache when fetching.\n */readonly cache:RequestCache;/**\n * Returns the credentials mode associated with request, which is a string\n * indicating whether credentials will be sent with the request always, never, or only when sent to a\n * same-origin URL.\n */readonly credentials:RequestCredentials;/**\n * Returns the kind of resource requested by request, e.g., "document" or\n * "script".\n */readonly destination:RequestDestination;/**\n * Returns a Headers object consisting of the headers associated with request.\n * Note that headers added in the network layer by the user agent will not be accounted for in this\n * object, e.g., the "Host" header.\n */readonly headers:Headers;/**\n * Returns request's subresource integrity metadata, which is a cryptographic hash of\n * the resource being fetched. Its value consists of multiple hashes separated by whitespace. [SRI]\n */readonly integrity:string ;/**\n * Returns a boolean indicating whether or not request is for a history\n * navigation (a.k.a. back-foward navigation).\n */readonly isHistoryNavigation:boolean ;/**\n * Returns a boolean indicating whether or not request is for a reload navigation.\n */readonly isReloadNavigation:boolean ;/**\n * Returns a boolean indicating whether or not request can outlive the global in which\n * it was created.\n */readonly keepalive:boolean ;/**\n * Returns request's HTTP method, which is "GET" by default.\n */readonly method:string ;/**\n * Returns the mode associated with request, which is a string indicating\n * whether the request will use CORS, or will be restricted to same-origin URLs.\n */readonly mode:RequestMode;/**\n * Returns the redirect mode associated with request, which is a string\n * indicating how redirects for the request will be handled during fetching. A request will follow redirects by default.\n */readonly redirect:RequestRedirect;/**\n * Returns the referrer of request. Its value can be a same-origin URL if\n * explicitly set in init, the empty string to indicate no referrer, and\n * "about:client" when defaulting to the global's default. This is used during\n * fetching to determine the value of the \`Referer\` header of the request being made.\n */readonly referrer:string ;/**\n * Returns the referrer policy associated with request. This is used during\n * fetching to compute the value of the request's referrer.\n */readonly referrerPolicy:ReferrerPolicy;/**\n * Returns the signal associated with request, which is an AbortSignal object indicating whether or not request has been aborted, and its abort\n * event handler.\n */readonly signal:object ;/**\n * Returns the URL of request as a string.\n */readonly url:string ;clone():Request;}declare var Request:{prototype:Request;new (input:RequestInfo,init?:RequestInit):Request;};interface Responseextends Body{readonly headers:Headers;readonly ok:boolean ;readonly redirected:boolean ;readonly status:number ;readonly statusText:string ;readonly trailer:Promise<Headers>;readonly type :ResponseType;readonly url:string ;clone():Response;}declare var Response:{prototype:Response;new (body?:BodyInit|null ,init?:ResponseInit):Response;error():Response;redirect(url:string ,status?:number ):Response;};interface ServiceWorkerEventMapextends AbstractWorkerEventMap{"statechange":Event;}interface ServiceWorkerextends EventTarget,AbstractWorker{onstatechange:((this :ServiceWorker,ev:Event)=>any )|null ;readonly scriptURL:string ;readonly state:ServiceWorkerState;postMessage(message:any ,transfer?:any []):void ;addEventListener<Kextends keyof ServiceWorkerEventMap>(type :K,listener:(this :ServiceWorker,ev:ServiceWorkerEventMap[K])=>any ,options?:boolean |AddEventListenerOptions):void ;addEventListener(type :string ,listener:EventListenerOrEventListenerObject,options?:boolean |AddEventListenerOptions):void ;removeEventListener<Kextends keyof ServiceWorkerEventMap>(type :K,listener:(this :ServiceWorker,ev:ServiceWorkerEventMap[K])=>any ,options?:boolean |EventListenerOptions):void ;removeEventListener(type :string ,listener:EventListenerOrEventListenerObject,options?:boolean |EventListenerOptions):void ;}declare var ServiceWorker:{prototype:ServiceWorker;new ():ServiceWorker;};interface ServiceWorkerContainerEventMap{"controllerchange":Event;"message":MessageEvent;"messageerror":MessageEvent;}interface ServiceWorkerContainerextends EventTarget{readonly controller:ServiceWorker|null ;oncontrollerchange:((this :ServiceWorkerContainer,ev:Event)=>any )|null ;onmessage:((this :ServiceWorkerContainer,ev:MessageEvent)=>any )|null ;onmessageerror:((this :ServiceWorkerContainer,ev:MessageEvent)=>any )|null ;readonly ready:Promise<ServiceWorkerRegistration>;getRegistration(clientURL?:string ):Promise<ServiceWorkerRegistration|undefined >;getRegistrations():Promise<ReadonlyArray<ServiceWorkerRegistration>>;register(scriptURL:string ,options?:RegistrationOptions):Promise<ServiceWorkerRegistration>;startMessages():void ;addEventListener<Kextends keyof ServiceWorkerContainerEventMap>(type :K,listener:(this :ServiceWorkerContainer,ev:ServiceWorkerContainerEventMap[K])=>any ,options?:boolean |AddEventListenerOptions):void ;addEventListener(type :string ,listener:EventListenerOrEventListenerObject,options?:boolean |AddEventListenerOptions):void ;removeEventListener<Kextends keyof ServiceWorkerContainerEventMap>(type :K,listener:(this :ServiceWorkerContainer,ev:ServiceWorkerContainerEventMap[K])=>any ,options?:boolean |EventListenerOptions):void ;removeEventListener(type :string ,listener:EventListenerOrEventListenerObject,options?:boolean |EventListenerOptions):void ;}declare var ServiceWorkerContainer:{prototype:ServiceWorkerContainer;new ():ServiceWorkerContainer;};interface ServiceWorkerGlobalScopeEventMapextends WorkerGlobalScopeEventMap{"activate":ExtendableEvent;"fetch":FetchEvent;"install":ExtendableEvent;"message":ExtendableMessageEvent;"messageerror":MessageEvent;"notificationclick":NotificationEvent;"notificationclose":NotificationEvent;"push":PushEvent;"pushsubscriptionchange":PushSubscriptionChangeEvent;"sync":SyncEvent;}interface ServiceWorkerGlobalScopeextends WorkerGlobalScope{readonly clients:Clients;onactivate:((this :ServiceWorkerGlobalScope,ev:ExtendableEvent)=>any )|null ;onfetch:((this :ServiceWorkerGlobalScope,ev:FetchEvent)=>any )|null ;oninstall:((this :ServiceWorkerGlobalScope,ev:ExtendableEvent)=>any )|null ;onmessage:((this :ServiceWorkerGlobalScope,ev:ExtendableMessageEvent)=>any )|null ;onmessageerror:((this :ServiceWorkerGlobalScope,ev:MessageEvent)=>any )|null ;onnotificationclick:((this :ServiceWorkerGlobalScope,ev:NotificationEvent)=>any )|null ;onnotificationclose:((this :ServiceWorkerGlobalScope,ev:NotificationEvent)=>any )|null ;onpush:((this :ServiceWorkerGlobalScope,ev:PushEvent)=>any )|null ;onpushsubscriptionchange:((this :ServiceWorkerGlobalScope,ev:PushSubscriptionChangeEvent)=>any )|null ;onsync:((this :ServiceWorkerGlobalScope,ev:SyncEvent)=>any )|null ;readonly registration:ServiceWorkerRegistration;skipWaiting():Promise<void >;addEventListener<Kextends keyof ServiceWorkerGlobalScopeEventMap>(type :K,listener:(this :ServiceWorkerGlobalScope,ev:ServiceWorkerGlobalScopeEventMap[K])=>any ,options?:boolean |AddEventListenerOptions):void ;addEventListener(type :string ,listener:EventListenerOrEventListenerObject,options?:boolean |AddEventListenerOptions):void ;removeEventListener<Kextends keyof ServiceWorkerGlobalScopeEventMap>(type :K,listener:(this :ServiceWorkerGlobalScope,ev:ServiceWorkerGlobalScopeEventMap[K])=>any ,options?:boolean |EventListenerOptions):void ;removeEventListener(type :string ,listener:EventListenerOrEventListenerObject,options?:boolean |EventListenerOptions):void ;}declare var ServiceWorkerGlobalScope:{prototype:ServiceWorkerGlobalScope;new ():ServiceWorkerGlobalScope;};interface ServiceWorkerRegistrationEventMap{"updatefound":Event;}interface ServiceWorkerRegistrationextends EventTarget{readonly active:ServiceWorker|null ;readonly installing:ServiceWorker|null ;readonly navigationPreload:NavigationPreloadManager;onupdatefound:((this :ServiceWorkerRegistration,ev:Event)=>any )|null ;readonly pushManager:PushManager;readonly scope:string ;readonly sync:SyncManager;readonly updateViaCache:ServiceWorkerUpdateViaCache;readonly waiting:ServiceWorker|null ;getNotifications(filter?:GetNotificationOptions):Promise<Notification[]>;showNotification(title:string ,options?:NotificationOptions):Promise<void >;unregister():Promise<boolean >;update():Promise<void >;addEventListener<Kextends keyof ServiceWorkerRegistrationEventMap>(type :K,listener:(this :ServiceWorkerRegistration,ev:ServiceWorkerRegistrationEventMap[K])=>any ,options?:boolean |AddEventListenerOptions):void ;addEventListener(type :string ,listener:EventListenerOrEventListenerObject,options?:boolean |AddEventListenerOptions):void ;removeEventListener<Kextends keyof ServiceWorkerRegistrationEventMap>(type :K,listener:(this :ServiceWorkerRegistration,ev:ServiceWorkerRegistrationEventMap[K])=>any ,options?:boolean |EventListenerOptions):void ;removeEventListener(type :string ,listener:EventListenerOrEventListenerObject,options?:boolean |EventListenerOptions):void ;}declare var ServiceWorkerRegistration:{prototype:ServiceWorkerRegistration;new ():ServiceWorkerRegistration;};interface StorageManager{estimate():Promise<StorageEstimate>;persisted():Promise<boolean >;}declare var StorageManager:{prototype:StorageManager;new ():StorageManager;};interface SyncEventextends ExtendableEvent{readonly lastChance:boolean ;readonly tag:string ;}declare var SyncEvent:{prototype:SyncEvent;new (type :string ,init:SyncEventInit):SyncEvent;};interface SyncManager{getTags():Promise<string []>;register(tag:string ):Promise<void >;}declare var SyncManager:{prototype:SyncManager;new ():SyncManager;};interface TextDecoder{/**\n * Returns encoding's name, lowercased.\n */readonly encoding:string ;/**\n * Returns true if error mode is "fatal", and false\n * otherwise.\n */readonly fatal:boolean ;/**\n * Returns true if ignore BOM flag is set, and false otherwise.\n */readonly ignoreBOM:boolean ;/**\n * Returns the result of running encoding's decoder. The\n * method can be invoked zero or more times with options's stream set to\n * true, and then once without options's stream (or set to false), to process\n * a fragmented stream. If the invocation without options's stream (or set to\n * false) has no input, it's clearest to omit both arguments.\n * var string = "", decoder = new TextDecoder(encoding), buffer;\n * while(buffer = next_chunk()) {\n * string += decoder.decode(buffer, {stream:true});\n * }\n * string += decoder.decode(); // end-of-stream\n * If the error mode is "fatal" and encoding's decoder returns error, throws a TypeError.\n */decode(input?:BufferSource,options?:TextDecodeOptions):string ;}declare var TextDecoder:{prototype:TextDecoder;new (label?:string ,options?:TextDecoderOptions):TextDecoder;};interface TextEncoder{/**\n * Returns "utf-8".\n */readonly encoding:string ;/**\n * Returns the result of running UTF-8's encoder.\n */encode(input?:string ):Uint8Array;}declare var TextEncoder:{prototype:TextEncoder;new ():TextEncoder;};interface URL{hash:string ;host:string ;hostname:string ;href:string ;readonly origin:string ;password:string ;pathname:string ;port:string ;protocol:string ;search:string ;readonly searchParams:URLSearchParams;username:string ;toJSON():string ;}declare var URL:{prototype:URL;new (url:string ,base?:string |URL):URL;createObjectURL(object :any ):string ;revokeObjectURL(url:string ):void ;};interface URLSearchParams{/**\n * Appends a specified key/value pair as a new search parameter.\n */append(name:string ,value:string ):void ;/**\n * Deletes the given search parameter, and its associated value, from the list of all search parameters.\n */delete (name:string ):void ;/**\n * Returns the first value associated to the given search parameter.\n */get (name:string ):string |null ;/**\n * Returns all the values association with a given search parameter.\n */getAll(name:string ):string [];/**\n * Returns a Boolean indicating if such a search parameter exists.\n */has(name:string ):boolean ;/**\n * Sets the value associated to a given search parameter to the given value. If there were several values, delete the others.\n */set (name:string ,value:string ):void ;sort():void ;forEach(callbackfn:(value:string ,key:string ,parent:URLSearchParams)=>void ,thisArg?:any ):void ;}declare var URLSearchParams:{prototype:URLSearchParams;new (init?:string [][]|Record<string ,string >|string |URLSearchParams):URLSearchParams;};interface WebSocketEventMap{"close":CloseEvent;"error":Event;"message":MessageEvent;"open":Event;}interface WebSocketextends EventTarget{binaryType:BinaryType;readonly bufferedAmount:number ;readonly extensions:string ;onclose:((this :WebSocket,ev:CloseEvent)=>any )|null ;onerror:((this :WebSocket,ev:Event)=>any )|null ;onmessage:((this :WebSocket,ev:MessageEvent)=>any )|null ;onopen:((this :WebSocket,ev:Event)=>any )|null ;readonly protocol:string ;readonly readyState:number ;readonly url:string ;close(code?:number ,reason?:string ):void ;send(data:string |ArrayBufferLike|Blob|ArrayBufferView):void ;readonly CLOSED:number ;readonly CLOSING:number ;readonly CONNECTING:number ;readonly OPEN:number ;addEventListener<Kextends keyof WebSocketEventMap>(type :K,listener:(this :WebSocket,ev:WebSocketEventMap[K])=>any ,options?:boolean |AddEventListenerOptions):void ;addEventListener(type :string ,listener:EventListenerOrEventListenerObject,options?:boolean |AddEventListenerOptions):void ;removeEventListener<Kextends keyof WebSocketEventMap>(type :K,listener:(this :WebSocket,ev:WebSocketEventMap[K])=>any ,options?:boolean |EventListenerOptions):void ;removeEventListener(type :string ,listener:EventListenerOrEventListenerObject,options?:boolean |EventListenerOptions):void ;}declare var WebSocket:{prototype:WebSocket;new (url:string ,protocols?:string |string []):WebSocket;readonly CLOSED:number ;readonly CLOSING:number ;readonly CONNECTING:number ;readonly OPEN:number ;};interface WindowBase64{atob(encodedString:string ):string ;btoa(rawString:string ):string ;}interface WindowClientextends Client{readonly ancestorOrigins:ReadonlyArray<string >;readonly focused:boolean ;readonly visibilityState:VisibilityState;focus():Promise<WindowClient>;navigate(url:string ):Promise<WindowClient|null >;}declare var WindowClient:{prototype:WindowClient;new ():WindowClient;};interface WindowConsole{readonly console:Console;}interface WorkerEventMapextends AbstractWorkerEventMap{"message":MessageEvent;}interface Workerextends EventTarget,AbstractWorker{onmessage:((this :Worker,ev:MessageEvent)=>any )|null ;postMessage(message:any ,transfer?:any []):void ;terminate():void ;addEventListener<Kextends keyof WorkerEventMap>(type :K,listener:(this :Worker,ev:WorkerEventMap[K])=>any ,options?:boolean |AddEventListenerOptions):void ;addEventListener(type :string ,listener:EventListenerOrEventListenerObject,options?:boolean |AddEventListenerOptions):void ;removeEventListener<Kextends keyof WorkerEventMap>(type :K,listener:(this :Worker,ev:WorkerEventMap[K])=>any ,options?:boolean |EventListenerOptions):void ;removeEventListener(type :string ,listener:EventListenerOrEventListenerObject,options?:boolean |EventListenerOptions):void ;}declare var Worker:{prototype:Worker;new (stringUrl:string ):Worker;};interface WorkerGlobalScopeEventMap{"error":ErrorEvent;}interface WorkerGlobalScopeextends EventTarget,WorkerUtils,WindowConsole,GlobalFetch{readonly caches:CacheStorage;readonly isSecureContext:boolean ;readonly location:WorkerLocation;onerror:((this :WorkerGlobalScope,ev:ErrorEvent)=>any )|null ;readonly performance:Performance;readonly self:WorkerGlobalScope;createImageBitmap(image:ImageBitmap|ImageData|Blob,options?:ImageBitmapOptions):Promise<ImageBitmap>;createImageBitmap(image:ImageBitmap|ImageData|Blob,sx:number ,sy:number ,sw:number ,sh:number ,options?:ImageBitmapOptions):Promise<ImageBitmap>;msWriteProfilerMark(profilerMarkName:string ):void ;addEventListener<Kextends keyof WorkerGlobalScopeEventMap>(type :K,listener:(this :WorkerGlobalScope,ev:WorkerGlobalScopeEventMap[K])=>any ,options?:boolean |AddEventListenerOptions):void ;addEventListener(type :string ,listener:EventListenerOrEventListenerObject,options?:boolean |AddEventListenerOptions):void ;removeEventListener<Kextends keyof WorkerGlobalScopeEventMap>(type :K,listener:(this :WorkerGlobalScope,ev:WorkerGlobalScopeEventMap[K])=>any ,options?:boolean |EventListenerOptions):void ;removeEventListener(type :string ,listener:EventListenerOrEventListenerObject,options?:boolean |EventListenerOptions):void ;}declare var WorkerGlobalScope:{prototype:WorkerGlobalScope;new ():WorkerGlobalScope;};interface WorkerLocation{readonly hash:string ;readonly host:string ;readonly hostname:string ;readonly href:string ;readonly origin:string ;readonly pathname:string ;readonly port:string ;readonly protocol:string ;readonly search:string ;toString():string ;}declare var WorkerLocation:{prototype:WorkerLocation;new ():WorkerLocation;};interface WorkerNavigatorextends NavigatorID,NavigatorOnLine,NavigatorBeacon,NavigatorConcurrentHardware,NavigatorStorage{readonly serviceWorker:ServiceWorkerContainer;}declare var WorkerNavigator:{prototype:WorkerNavigator;new ():WorkerNavigator;};interface WorkerUtilsextends WindowBase64{readonly indexedDB:IDBFactory;readonly msIndexedDB:IDBFactory;readonly navigator:WorkerNavigator;clearImmediate(handle:number ):void ;clearInterval(handle:number ):void ;clearTimeout(handle:number ):void ;importScripts(...urls:string []):void ;setImmediate(handler:any ,...args:any []):number ;setInterval(handler:any ,timeout?:any ,...args:any []):number ;setTimeout(handler:any ,timeout?:any ,...args:any []):number ;}interface XMLHttpRequestEventMapextends XMLHttpRequestEventTargetEventMap{"readystatechange":Event;}interface XMLHttpRequestextends XMLHttpRequestEventTarget{onreadystatechange:((this :XMLHttpRequest,ev:Event)=>any )|null ;/**\n * Returns client's state.\n */readonly readyState:number ;/**\n * Returns the response's body.\n */readonly response:any ;/**\n * Returns the text response.\n * Throws an "InvalidStateError" DOMException if responseType is not the empty string or "text".\n */readonly responseText:string ;/**\n * Returns the response type.\n * Can be set to change the response type. Values are:\n * the empty string (default),\n * "arraybuffer",\n * "blob",\n * "document",\n * "json", and\n * "text".\n * When set: setting to "document" is ignored if current global object is not a Window object.\n * When set: throws an "InvalidStateError" DOMException if state is loading or done.\n * When set: throws an "InvalidAccessError" DOMException if the synchronous flag is set and current global object is a Window object.\n */responseType:XMLHttpRequestResponseType;readonly responseURL:string ;readonly status:number ;readonly statusText:string ;/**\n * Can be set to a time in milliseconds. When set to a non-zero value will cause fetching to terminate after the given time has passed. When the time has passed, the\n * request has not yet completed, and the synchronous flag is unset, a timeout event will then be dispatched, or a\n * "TimeoutError" DOMException will be thrown otherwise (for the send() method).\n * When set: throws an "InvalidAccessError" DOMException if the synchronous flag is set and current global object is a Window object.\n */timeout:number ;/**\n * Returns the associated XMLHttpRequestUpload object. It can be used to gather transmission information when data is\n * transferred to a server.\n */readonly upload:XMLHttpRequestUpload;/**\n * True when credentials are to be included in a cross-origin request. False when they are\n * to be excluded in a cross-origin request and when cookies are to be ignored in its response.\n * Initially false.\n * When set: throws an "InvalidStateError" DOMException if state is not unsent or opened, or if the send() flag is set.\n */withCredentials:boolean ;/**\n * Cancels any network activity.\n */abort():void ;getAllResponseHeaders():string ;getResponseHeader(name:string ):string |null ;/**\n * Sets the request method, request URL, and synchronous flag.\n * Throws a "SyntaxError" DOMException if either method is not a\n * valid HTTP method or url cannot be parsed.\n * Throws a "SecurityError" DOMException if method is a\n * case-insensitive match for \`CONNECT\`, \`TRACE\`, or \`TRACK\`.\n * Throws an "InvalidAccessError" DOMException if async is false, current global object is a Window object, and the timeout attribute is not zero or the responseType attribute is not the empty string.\n */open(method:string ,url:string ):void ;open(method:string ,url:string ,async :boolean ,username?:string |null ,password?:string |null ):void ;/**\n * Acts as if the \`Content-Type\` header value for response is mime.\n * (It does not actually change the header though.)\n * Throws an "InvalidStateError" DOMException if state is loading or done.\n */overrideMimeType(mime:string ):void ;/**\n * Initiates the request. The optional argument provides the request body. The argument is ignored if request method is GET or HEAD.\n * Throws an "InvalidStateError" DOMException if either state is not opened or the send() flag is set.\n */send(body?:object |BodyInit):void ;/**\n * Combines a header in author request headers.\n * Throws an "InvalidStateError" DOMException if either state is not opened or the send() flag is set.\n * Throws a "SyntaxError" DOMException if name is not a header name\n * or if value is not a header value.\n */setRequestHeader(name:string ,value:string ):void ;readonly DONE:number ;readonly HEADERS_RECEIVED:number ;readonly LOADING:number ;readonly OPENED:number ;readonly UNSENT:number ;addEventListener<Kextends keyof XMLHttpRequestEventMap>(type :K,listener:(this :XMLHttpRequest,ev:XMLHttpRequestEventMap[K])=>any ,options?:boolean |AddEventListenerOptions):void ;addEventListener(type :string ,listener:EventListenerOrEventListenerObject,options?:boolean |AddEventListenerOptions):void ;removeEventListener<Kextends keyof XMLHttpRequestEventMap>(type :K,listener:(this :XMLHttpRequest,ev:XMLHttpRequestEventMap[K])=>any ,options?:boolean |EventListenerOptions):void ;removeEventListener(type :string ,listener:EventListenerOrEventListenerObject,options?:boolean |EventListenerOptions):void ;}declare var XMLHttpRequest:{prototype:XMLHttpRequest;new ():XMLHttpRequest;readonly DONE:number ;readonly HEADERS_RECEIVED:number ;readonly LOADING:number ;readonly OPENED:number ;readonly UNSENT:number ;};interface XMLHttpRequestEventTargetEventMap{"abort":ProgressEvent;"error":ProgressEvent;"load":ProgressEvent;"loadend":ProgressEvent;"loadstart":ProgressEvent;"progress":ProgressEvent;"timeout":ProgressEvent;}interface XMLHttpRequestEventTargetextends EventTarget{onabort:((this :XMLHttpRequest,ev:ProgressEvent)=>any )|null ;onerror:((this :XMLHttpRequest,ev:ProgressEvent)=>any )|null ;onload:((this :XMLHttpRequest,ev:ProgressEvent)=>any )|null ;onloadend:((this :XMLHttpRequest,ev:ProgressEvent)=>any )|null ;onloadstart:((this :XMLHttpRequest,ev:ProgressEvent)=>any )|null ;onprogress:((this :XMLHttpRequest,ev:ProgressEvent)=>any )|null ;ontimeout:((this :XMLHttpRequest,ev:ProgressEvent)=>any )|null ;addEventListener<Kextends keyof XMLHttpRequestEventTargetEventMap>(type :K,listener:(this :XMLHttpRequestEventTarget,ev:XMLHttpRequestEventTargetEventMap[K])=>any ,options?:boolean |AddEventListenerOptions):void ;addEventListener(type :string ,listener:EventListenerOrEventListenerObject,options?:boolean |AddEventListenerOptions):void ;removeEventListener<Kextends keyof XMLHttpRequestEventTargetEventMap>(type :K,listener:(this :XMLHttpRequestEventTarget,ev:XMLHttpRequestEventTargetEventMap[K])=>any ,options?:boolean |EventListenerOptions):void ;removeEventListener(type :string ,listener:EventListenerOrEventListenerObject,options?:boolean |EventListenerOptions):void ;}declare var XMLHttpRequestEventTarget:{prototype:XMLHttpRequestEventTarget;new ():XMLHttpRequestEventTarget;};interface XMLHttpRequestUploadextends XMLHttpRequestEventTarget{addEventListener<Kextends keyof XMLHttpRequestEventTargetEventMap>(type :K,listener:(this :XMLHttpRequestUpload,ev:XMLHttpRequestEventTargetEventMap[K])=>any ,options?:boolean |AddEventListenerOptions):void ;addEventListener(type :string ,listener:EventListenerOrEventListenerObject,options?:boolean |AddEventListenerOptions):void ;removeEventListener<Kextends keyof XMLHttpRequestEventTargetEventMap>(type :K,listener:(this :XMLHttpRequestUpload,ev:XMLHttpRequestEventTargetEventMap[K])=>any ,options?:boolean |EventListenerOptions):void ;removeEventListener(type :string ,listener:EventListenerOrEventListenerObject,options?:boolean |EventListenerOptions):void ;}declare var XMLHttpRequestUpload:{prototype:XMLHttpRequestUpload;new ():XMLHttpRequestUpload;};declare type EventListenerOrEventListenerObject=EventListener|EventListenerObject;interface EventHandlerNonNull{(event:Event):any ;}interface PerformanceObserverCallback{(entries:PerformanceObserverEntryList,observer:PerformanceObserver):void ;}declare var onmessage:((this :DedicatedWorkerGlobalScope,ev:MessageEvent)=>any )|null ;declare function close():void ;declare function postMessage(message:any ,transfer?:any []):void ;declare function dispatchEvent(evt:Event):boolean ;declare var caches:CacheStorage;declare var isSecureContext:boolean ;declare var location:WorkerLocation;declare var onerror:((this :DedicatedWorkerGlobalScope,ev:ErrorEvent)=>any )|null ;declare var performance:Performance;declare var self:WorkerGlobalScope;declare function createImageBitmap(image:ImageBitmap|ImageData|Blob,options?:ImageBitmapOptions):Promise<ImageBitmap>;declare function createImageBitmap(image:ImageBitmap|ImageData|Blob,sx:number ,sy:number ,sw:number ,sh:number ,options?:ImageBitmapOptions):Promise<ImageBitmap>;declare function msWriteProfilerMark(profilerMarkName:string ):void ;declare function dispatchEvent(evt:Event):boolean ;declare var indexedDB:IDBFactory;declare var msIndexedDB:IDBFactory;declare var navigator:WorkerNavigator;declare function clearImmediate(handle:number ):void ;declare function clearInterval(handle:number ):void ;declare function clearTimeout(handle:number ):void ;declare function setImmediate(handler:any ,...args:any []):number ;declare function setInterval(handler:any ,timeout?:any ,...args:any []):number ;declare function setTimeout(handler:any ,timeout?:any ,...args:any []):number ;declare function atob(encodedString:string ):string ;declare function btoa(rawString:string ):string ;declare var console:Console;declare function fetch(input?:Request|string ,init?:RequestInit):Promise<Response>;declare function addEventListener<Kextends keyof DedicatedWorkerGlobalScopeEventMap>(type :K,listener:(this :DedicatedWorkerGlobalScope,ev:DedicatedWorkerGlobalScopeEventMap[K])=>any ,options?:boolean |AddEventListenerOptions):void ;declare function addEventListener(type :string ,listener:EventListenerOrEventListenerObject,options?:boolean |AddEventListenerOptions):void ;declare function removeEventListener<Kextends keyof DedicatedWorkerGlobalScopeEventMap>(type :K,listener:(this :DedicatedWorkerGlobalScope,ev:DedicatedWorkerGlobalScopeEventMap[K])=>any ,options?:boolean |EventListenerOptions):void ;declare function removeEventListener(type :string ,listener:EventListenerOrEventListenerObject,options?:boolean |EventListenerOptions):void ;type BlobPart=BufferSource|Blob|string ;type HeadersInit=Headers|string [][]|Record<string ,string >;type BodyInit=Blob|BufferSource|FormData|URLSearchParams|ReadableStream|string ;type RequestInfo=Request|string ;type DOMHighResTimeStamp=number ;type PerformanceEntryList=PerformanceEntry[];type PushMessageDataInit=BufferSource|string ;type VibratePattern=number |number [];type BufferSource=ArrayBufferView|ArrayBuffer;type DOMTimeStamp=number ;type FormDataEntryValue=File|string ;type IDBValidKey=number |string |Date|BufferSource|IDBArrayKey;type MessageEventSource=object |MessagePort|ServiceWorker;type BinaryType="blob"|"arraybuffer";type ClientTypes="window"|"worker"|"sharedworker"|"all";type IDBCursorDirection="next"|"nextunique"|"prev"|"prevunique";type IDBRequestReadyState="pending"|"done";type IDBTransactionMode="readonly"|"readwrite"|"versionchange";type NotificationDirection="auto"|"ltr"|"rtl";type NotificationPermission="default"|"denied"|"granted";type PushEncryptionKeyName="p256dh"|"auth";type PushPermissionState="denied"|"granted"|"prompt";type ReferrerPolicy=""|"no-referrer"|"no-referrer-when-downgrade"|"origin-only"|"origin-when-cross-origin"|"unsafe-url";type RequestCache="default"|"no-store"|"reload"|"no-cache"|"force-cache"|"only-if-cached";type RequestCredentials="omit"|"same-origin"|"include";type RequestDestination=""|"audio"|"audioworklet"|"document"|"embed"|"font"|"image"|"manifest"|"object"|"paintworklet"|"report"|"script"|"sharedworker"|"style"|"track"|"video"|"worker"|"xslt";type RequestMode="navigate"|"same-origin"|"no-cors"|"cors";type RequestRedirect="follow"|"error"|"manual";type ResponseType="basic"|"cors"|"default"|"error"|"opaque"|"opaqueredirect";type ServiceWorkerState="installing"|"installed"|"activating"|"activated"|"redundant";type ServiceWorkerUpdateViaCache="imports"|"all"|"none";type VisibilityState="hidden"|"visible"|"prerender"|"unloaded";type WorkerType="classic"|"module";type XMLHttpRequestResponseType=""|"arraybuffer"|"blob"|"document"|"json"|"text";`
};